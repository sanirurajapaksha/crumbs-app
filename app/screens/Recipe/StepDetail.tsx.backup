import React, { useState, useEffect, useRef } from "react";
import { View, Text, StyleSheet, TouchableOpacity, Image, Dimensions, ScrollView, ActivityIndicator, Alert } from "react-native";
import { useLocalSearchParams, useRouter } from "expo-router";
import { MaterialIcons } from "@expo/vector-icons";
import { useStore, StoreState } from "../../store/useStore";
import { colors } from "../../theme/colors";
import * as Speech from 'expo-speech';
import { recordAndTranscribeVoiceCommand, startContinuousListening, VoiceCommandResult } from '../../api/handsFreeCookingApi';

const { width } = Dimensions.get("window");

type CookingMode = 'interactive' | 'manual';

export default function StepDetail() {
    const { id, step, mode } = useLocalSearchParams<{ id: string; step: string; mode?: string }>();
    const favorites = useStore((s: StoreState) => s.favorites);
    const myRecipes = useStore((s: StoreState) => s.myRecipes);
    const user = useStore((s: StoreState) => s.user);
    const router = useRouter();
    
    const cookingMode: CookingMode = (mode as CookingMode) || 'manual';
    
    const [showProgress, setShowProgress] = useState(false);
    const [stepImageUrl, setStepImageUrl] = useState<string | null>(null);
    const [imageLoading, setImageLoading] = useState(true);
    const [isSpeaking, setIsSpeaking] = useState(false);
    const [isListening, setIsListening] = useState(false);
    const [recognizedText, setRecognizedText] = useState('');
    const [micPermissionGranted, setMicPermissionGranted] = useState(false);
    const [micPermissionDenied, setMicPermissionDenied] = useState(false);
    
    const stopListeningRef = useRef<(() => void) | null>(null);
    const isFirstStepRef = useRef(true);

    // Check both favorites and myRecipes
    let recipe = favorites.find((r: any) => r.id === id);
    if (!recipe) {
        recipe = myRecipes.find((r: any) => r.id === id);
    }

    if (!recipe) {
        return (
            <View style={styles.center}>
                <Text>No recipe</Text>
            </View>
        );
    }

    const current = recipe.steps.find((s: any) => String(s.stepNumber) === step) || recipe.steps[0];
    const idx = recipe.steps.indexOf(current);
    
    // Generate image for current step
    useEffect(() => {
        const generateStepImage = async () => {
            if (current.image) {
                setStepImageUrl(current.image);
                setImageLoading(false);
                return;
            }

            try {
                setImageLoading(true);
                
                const stepText = current.text.toLowerCase();
                const stepWords = stepText.split(' ');
                
                const cookingActions = ['chop', 'slice', 'dice', 'mince', 'mix', 'stir', 'whisk', 'beat', 
                                       'fold', 'knead', 'roll', 'cut', 'peel', 'grate', 'blend', 'pour',
                                       'heat', 'boil', 'simmer', 'fry', 'sauté', 'bake', 'roast', 'grill',
                                       'season', 'marinate', 'coat', 'garnish', 'serve', 'arrange'];
                
                const action = stepWords.find(word => cookingActions.includes(word)) || 'cooking';
                const ingredientIndex = stepWords.findIndex(word => cookingActions.includes(word)) + 1;
                const ingredient = stepWords[ingredientIndex] || '';
                
                const recipeName = recipe.title.split(' ')[0];
                const stepNumber = current.stepNumber;
                
                const pollinationsPrompt = encodeURIComponent(
                    `${action} ${ingredient} for ${recipe.title}, step ${stepNumber}, professional food photography, close-up cooking action`
                );
                const seed = stepNumber * 1000 + recipe.title.length;
                const pollinationsUrl = `https://image.pollinations.ai/prompt/${pollinationsPrompt}?width=800&height=600&nologo=true&seed=${seed}`;
                
                setStepImageUrl(pollinationsUrl);
                setImageLoading(false);
            } catch (error) {
                console.error('Error generating step image:', error);
                setImageLoading(false);
            }
        };

        generateStepImage();
    }, [step, current.text, current.stepNumber, recipe.title]);
    
    // Initialize hands-free mode on first step
    useEffect(() => {
        if (cookingMode === 'interactive' && isFirstStepRef.current) {
            isFirstStepRef.current = false;
            initializeHandsFreeCooking();
        }

        // Cleanup on unmount
        return () => {
            if (stopListeningRef.current) {
                stopListeningRef.current();
            }
            Speech.stop();
        };
    }, []);

    // Auto-speak when step changes in interactive mode
    useEffect(() => {
        if (cookingMode === 'interactive' && !isFirstStepRef.current && micPermissionGranted) {
            speakCurrentStep();
        }
    }, [step]);

    const initializeHandsFreeCooking = async () => {
        try {
            // Request microphone permissions
            const { Audio } = await import('expo-av');
            const { granted } = await Audio.requestPermissionsAsync();
            
            if (!granted) {
                setMicPermissionDenied(true);
                Alert.alert(
                    'Microphone Permission Required',
                    'Hands-free cooking requires microphone access to listen to your voice commands. Please enable microphone permission in your device settings.',
                    [
                        { text: 'Use Manual Mode', onPress: () => router.back() },
                        { text: 'OK' }
                    ]
                );
                return;
            }

            setMicPermissionGranted(true);

            // Welcome message
            const userName = user?.name || 'Chef';
            const welcomeMessage = `Hello ${userName}, let's start cooking ${recipe.title}`;
            
            Speech.speak(welcomeMessage, {
                language: 'en-US',
                pitch: 1.0,
                rate: 0.85,
                onDone: () => {
                    // After welcome, speak first step
                    speakCurrentStep();
                }
            });

        } catch (error) {
            console.error('Error initializing hands-free cooking:', error);
            Alert.alert(
                'Initialization Error',
                'Failed to start hands-free cooking mode. Would you like to continue in manual mode?',
                [
                    { text: 'Manual Mode', onPress: () => router.back() },
                    { text: 'Retry', onPress: () => initializeHandsFreeCooking() }
                ]
            );
        }
    };

    const speakCurrentStep = () => {
        setIsSpeaking(true);
        const textToSpeak = `Step ${current.stepNumber}. ${current.text}`;
        
        Speech.speak(textToSpeak, {
            language: 'en-US',
            pitch: 1.0,
            rate: 0.85,
            onDone: () => {
                setIsSpeaking(false);
                // Start listening for voice commands after speaking
                if (cookingMode === 'interactive') {
                    startVoiceListening();
                }
            },
            onStopped: () => {
                setIsSpeaking(false);
            },
            onError: (error) => {
                console.error('Speech error:', error);
                setIsSpeaking(false);
            }
        });
    };

    const startVoiceListening = async () => {
        if (isListening) return;

        setIsListening(true);
        setRecognizedText('🎤 Listening for your command...');

        try {
            // Start continuous listening
            const stopFn = await startContinuousListening(
                (result: VoiceCommandResult) => {
                    console.log('🎯 Command received:', result.command);
                    setRecognizedText(`Heard: "${result.transcript}"`);
                    
                    // Execute the command
                    handleVoiceCommand(result.command);
                },
                (error: Error) => {
                    console.error('❌ Listening error:', error);
                    // Don't stop listening on error, just log it
                }
            );

            stopListeningRef.current = stopFn;

        } catch (error: any) {
            console.error('❌ Failed to start listening:', error);
            setIsListening(false);
            setRecognizedText('');
            
            Alert.alert(
                'Voice Recognition Error',
                'Failed to start voice listening. Please use the buttons below or try again.',
                [{ text: 'OK' }]
            );
        }
    };

    const stopVoiceListening = () => {
        if (stopListeningRef.current) {
            stopListeningRef.current();
            stopListeningRef.current = null;
        }
        setIsListening(false);
        setRecognizedText('');
    };

    const handleVoiceCommand = (command: 'next' | 'previous' | 'repeat' | 'unknown') => {
        // Stop listening temporarily while processing command
        stopVoiceListening();
        
        if (command === 'next') {
            go(1);
        } else if (command === 'previous') {
            go(-1);
        } else if (command === 'repeat') {
            speakCurrentStep();
        }
        // Note: Don't restart listening here, it will auto-start after TTS finishes
    };
    
    // Manual mode: button to toggle TTS
    const handleManualSpeak = async () => {
        if (isSpeaking) {
            await Speech.stop();
            setIsSpeaking(false);
        } else {
            speakCurrentStep();
        }
    };
    
    const go = (n: number) => {
        const next = recipe.steps[idx + n];
        if (next) {
            router.replace({ 
                pathname: "./StepDetail", 
                params: { id: recipe.id, step: next.stepNumber, mode: cookingMode } 
            });
        }
    };

    const isLastStep = idx === recipe.steps.length - 1;
    const progressPercent = ((idx + 1) / recipe.steps.length) * 100;

    return (
        <View style={styles.container}>
            {/* Mode Indicator */}
            <View style={styles.modeIndicator}>
                <MaterialIcons 
                    name={cookingMode === 'interactive' ? 'mic' : 'touch-app'} 
                    size={16} 
                    color={colors.accent} 
                />
                <Text style={styles.modeText}>
                    {cookingMode === 'interactive' ? '🎙️ Hands-Free Mode' : '👆 Manual Mode'}
                </Text>
            </View>

            {/* Progress Bar */}
            <View style={styles.progressContainer}>
                <View style={styles.progressBar}>
                    <View style={[styles.progressFill, { width: `${progressPercent}%` }]} />
                </View>
                <Text style={styles.progressText}>Step {idx + 1} of {recipe.steps.length}</Text>
                <TouchableOpacity onPress={() => setShowProgress(!showProgress)}>
                    <MaterialIcons name="list" size={24} color={colors.textPrimary} />
                </TouchableOpacity>
            </View>

            <ScrollView contentContainerStyle={styles.content}>
                {/* Step Content */}
                <View style={styles.stepContainer}>
                    {/* Step Image */}
                    <View style={styles.stepImageContainer}>
                        {imageLoading ? (
                            <View style={styles.stepImagePlaceholder}>
                                <ActivityIndicator size="large" color={colors.accent} />
                                <Text style={styles.loadingImageText}>Loading image...</Text>
                            </View>
                        ) : stepImageUrl ? (
                            <Image 
                                source={{ uri: stepImageUrl }} 
                                style={styles.stepImage}
                                resizeMode="cover"
                                onError={() => {
                                    setStepImageUrl('https://source.unsplash.com/800x600/?cooking,food');
                                }}
                            />
                        ) : (
                            <View style={styles.stepImagePlaceholder}>
                                <MaterialIcons name="image" size={64} color="#ccc" />
                                <Text style={styles.noImageText}>No image available</Text>
                            </View>
                        )}
                    </View>

                    {/* Step Title */}
                    <Text style={styles.stepTitle}>Step {current.stepNumber}</Text>
                    
                    {/* Detailed instruction text */}
                    <View style={styles.instructionBox}>
                        <Text style={styles.instructionLabel}>Instructions:</Text>
                        <Text style={styles.stepInstruction}>{current.text}</Text>
                    </View>

                    {/* Interactive Mode Status */}
                    {cookingMode === 'interactive' && (
                        <View style={styles.interactiveStatus}>
                            {micPermissionDenied ? (
                                <View style={styles.permissionDenied}>
                                    <MaterialIcons name="mic-off" size={24} color="#E74C3C" />
                                    <Text style={styles.permissionDeniedText}>
                                        Microphone permission denied. Please enable it in settings.
                                    </Text>
                                </View>
                            ) : (
                                <>
                                    {isSpeaking && (
                                        <View style={styles.speakingIndicator}>
                                            <MaterialIcons name="volume-up" size={24} color={colors.accent} />
                                            <Text style={styles.speakingText}>Reading instructions...</Text>
                                        </View>
                                    )}
                                    
                                    {isListening && !isSpeaking && (
                                        <View style={styles.listeningIndicator}>
                                            <View style={styles.pulseCircle}>
                                                <MaterialIcons name="mic" size={32} color={colors.accent} />
                                            </View>
                                            <Text style={styles.listeningText}>{recognizedText}</Text>
                                            <Text style={styles.listeningSubtext}>
                                                Say "Next", "Previous", or "Repeat"
                                            </Text>
                                        </View>
                                    )}
                                </>
                            )}
                        </View>
                    )}

                    {/* Manual Mode: Listen Button */}
                    {cookingMode === 'manual' && (
                        <TouchableOpacity 
                            style={[styles.listenButton, isSpeaking && styles.listenButtonActive]} 
                            onPress={handleManualSpeak}
                        >
                            <MaterialIcons 
                                name={isSpeaking ? "volume-off" : "volume-up"} 
                                size={20} 
                                color={isSpeaking ? "#fff" : colors.accent} 
                            />
                            <Text style={[styles.listenText, isSpeaking && styles.listenTextActive]}>
                                {isSpeaking ? "Stop Reading" : "Listen to Instructions"}
                            </Text>
                        </TouchableOpacity>
                    )}
                </View>
            </ScrollView>

            {/* Navigation Buttons (Always visible for fallback) */}
            <View style={styles.navigationContainer}>
                <TouchableOpacity 
                    style={[styles.navButton, styles.backButton, idx === 0 && styles.navButtonDisabled]} 
                    onPress={() => go(-1)} 
                    disabled={idx === 0}
                >
                    <MaterialIcons name="arrow-back" size={20} color={idx === 0 ? "#ccc" : colors.textPrimary} />
                    <Text style={[styles.navButtonText, idx === 0 && styles.navButtonTextDisabled]}>Back</Text>
                </TouchableOpacity>
                
                <TouchableOpacity 
                    style={[styles.navButton, styles.repeatButton]} 
                    onPress={() => speakCurrentStep()}
                >
                    <MaterialIcons name="replay" size={20} color={colors.textPrimary} />
                    <Text style={styles.navButtonText}>Repeat</Text>
                </TouchableOpacity>
                
                <TouchableOpacity 
                    style={[styles.navButton, styles.nextButton]} 
                    onPress={() => {
                        if (isLastStep) {
                            router.push({
                                pathname: "/screens/Recipe/RecipeCompletionScreen",
                                params: { id: recipe.id }
                            });
                        } else {
                            go(1);
                        }
                    }}
                >
                    <Text style={styles.nextButtonText}>{isLastStep ? "Finish" : "Next"}</Text>
                    <MaterialIcons name="arrow-forward" size={20} color="#fff" />
                </TouchableOpacity>
            </View>

            {/* Progress Modal Overlay */}
            {showProgress && (
                <TouchableOpacity 
                    style={styles.modalOverlay} 
                    activeOpacity={1} 
                    onPress={() => setShowProgress(false)}
                >
                    <View style={styles.progressModal}>
                        <View style={styles.modalHeader}>
                            <Text style={styles.modalTitle}>Your Progress</Text>
                            <TouchableOpacity onPress={() => setShowProgress(false)}>
                                <MaterialIcons name="close" size={24} color={colors.textPrimary} />
                            </TouchableOpacity>
                        </View>
                        <Text style={styles.completedText}>
                            You've completed {idx + 1} of {recipe.steps.length} steps!
                        </Text>
                        
                        <ScrollView style={styles.stepsList}>
                            {recipe.steps.map((s: any, index: number) => (
                                <TouchableOpacity
                                    key={s.stepNumber}
                                    style={styles.progressStepItem}
                                    onPress={() => {
                                        setShowProgress(false);
                                        router.replace({
                                            pathname: "./StepDetail",
                                            params: { id: recipe.id, step: s.stepNumber, mode: cookingMode }
                                        });
                                    }}
                                >
                                    <View style={[
                                        styles.progressStepCircle,
                                        index < idx && styles.progressStepCircleCompleted,
                                        index === idx && styles.progressStepCircleActive
                                    ]}>
                                        {index < idx ? (
                                            <MaterialIcons name="check" size={16} color="#fff" />
                                        ) : (
                                            <Text style={[
                                                styles.progressStepNumber,
                                                index === idx && styles.progressStepNumberActive
                                            ]}>{index + 1}</Text>
                                        )}
                                    </View>
                                    <Text style={[
                                        styles.progressStepText,
                                        index < idx && styles.progressStepTextCompleted,
                                        index === idx && styles.progressStepTextActive
                                    ]}>
                                        Step {index + 1}: {s.text.substring(0, 30)}...
                                    </Text>
                                </TouchableOpacity>
                            ))}
                        </ScrollView>

                        <TouchableOpacity 
                            style={styles.resumeButton}
                            onPress={() => setShowProgress(false)}
                        >
                            <Text style={styles.resumeButtonText}>Resume Cooking</Text>
                        </TouchableOpacity>
                    </View>
                </TouchableOpacity>
            )}
        </View>
    );
}

const styles = StyleSheet.create({
    center: { 
        flex: 1, 
        alignItems: "center", 
        justifyContent: "center",
        backgroundColor: "#FFF5F0",
    },
    container: { 
        flex: 1,
        backgroundColor: "#FFF5F0",
    },
    modeIndicator: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'center',
        paddingVertical: 8,
        paddingHorizontal: 16,
        backgroundColor: '#FFE5DC',
        gap: 6,
    },
    modeText: {
        fontSize: 13,
        fontWeight: '600',
        color: colors.accent,
    },
    progressContainer: {
        flexDirection: "row",
        alignItems: "center",
        paddingHorizontal: 16,
        paddingTop: 12,
        paddingBottom: 12,
        gap: 12,
    },
    progressBar: {
        flex: 1,
        height: 6,
        backgroundColor: "#E0E0E0",
        borderRadius: 3,
        overflow: "hidden",
    },
    progressFill: {
        height: "100%",
        backgroundColor: colors.accent,
        borderRadius: 3,
    },
    progressText: {
        fontSize: 13,
        fontWeight: "600",
        color: colors.textMuted,
    },
    content: {
        paddingHorizontal: 16,
        paddingBottom: 100,
    },
    stepContainer: {
        marginTop: 8,
    },
    stepImageContainer: {
        width: "100%",
        height: 240,
        borderRadius: 20,
        overflow: "hidden",
        marginBottom: 20,
        backgroundColor: "#F0F0F0",
    },
    stepImage: {
        width: "100%",
        height: "100%",
    },
    stepImagePlaceholder: {
        width: "100%",
        height: "100%",
        justifyContent: "center",
        alignItems: "center",
        backgroundColor: "#F5F5F5",
    },
    loadingImageText: {
        marginTop: 12,
        fontSize: 14,
        color: colors.textMuted,
    },
    noImageText: {
        marginTop: 12,
        fontSize: 14,
        color: "#ccc",
    },
    stepTitle: {
        fontSize: 28,
        fontWeight: "800",
        color: colors.textPrimary,
        marginBottom: 16,
    },
    instructionBox: {
        backgroundColor: "#fff",
        padding: 20,
        borderRadius: 16,
        marginBottom: 16,
        shadowColor: "#000",
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.05,
        shadowRadius: 8,
        elevation: 2,
    },
    instructionLabel: {
        fontSize: 14,
        fontWeight: "700",
        color: colors.accent,
        marginBottom: 8,
        textTransform: "uppercase",
        letterSpacing: 0.5,
    },
    stepInstruction: {
        fontSize: 16,
        lineHeight: 26,
        color: colors.textPrimary,
    },
    interactiveStatus: {
        marginTop: 16,
    },
    permissionDenied: {
        backgroundColor: '#FEE',
        padding: 16,
        borderRadius: 12,
        flexDirection: 'row',
        alignItems: 'center',
        gap: 12,
    },
    permissionDeniedText: {
        flex: 1,
        fontSize: 14,
        color: '#E74C3C',
        fontWeight: '600',
    },
    speakingIndicator: {
        backgroundColor: '#FFF5E6',
        padding: 16,
        borderRadius: 12,
        flexDirection: 'row',
        alignItems: 'center',
        gap: 12,
    },
    speakingText: {
        fontSize: 15,
        fontWeight: '600',
        color: colors.accent,
    },
    listeningIndicator: {
        backgroundColor: '#F0F8FF',
        padding: 24,
        borderRadius: 16,
        alignItems: 'center',
    },
    pulseCircle: {
        width: 80,
        height: 80,
        borderRadius: 40,
        backgroundColor: colors.accent,
        justifyContent: 'center',
        alignItems: 'center',
        marginBottom: 16,
    },
    listeningText: {
        fontSize: 16,
        fontWeight: '600',
        color: colors.textPrimary,
        marginBottom: 8,
        textAlign: 'center',
    },
    listeningSubtext: {
        fontSize: 13,
        color: colors.textMuted,
        textAlign: 'center',
    },
    listenButton: {
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "center",
        backgroundColor: "#fff",
        paddingVertical: 16,
        paddingHorizontal: 24,
        borderRadius: 12,
        marginTop: 16,
        gap: 8,
        borderWidth: 2,
        borderColor: colors.accent,
    },
    listenButtonActive: {
        backgroundColor: colors.accent,
    },
    listenText: {
        fontSize: 16,
        fontWeight: "700",
        color: colors.accent,
    },
    listenTextActive: {
        color: "#fff",
    },
    navigationContainer: {
        position: "absolute",
        bottom: 0,
        left: 0,
        right: 0,
        flexDirection: "row",
        paddingHorizontal: 16,
        paddingVertical: 16,
        paddingBottom: 24,
        backgroundColor: "#FFF5F0",
        borderTopWidth: 1,
        borderTopColor: "#E0E0E0",
        gap: 12,
    },
    navButton: {
        flex: 1,
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "center",
        paddingVertical: 14,
        borderRadius: 12,
        gap: 6,
    },
    backButton: {
        backgroundColor: "#fff",
        borderWidth: 1.5,
        borderColor: "#E0E0E0",
    },
    repeatButton: {
        backgroundColor: "#fff",
        borderWidth: 1.5,
        borderColor: "#E0E0E0",
    },
    nextButton: {
        backgroundColor: colors.accent,
        shadowColor: colors.accent,
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.3,
        shadowRadius: 4,
        elevation: 3,
    },
    navButtonDisabled: {
        backgroundColor: "#F5F5F5",
        borderColor: "#E0E0E0",
    },
    navButtonText: {
        fontSize: 15,
        fontWeight: "700",
        color: colors.textPrimary,
    },
    navButtonTextDisabled: {
        color: "#ccc",
    },
    nextButtonText: {
        fontSize: 15,
        fontWeight: "700",
        color: "#fff",
    },
    modalOverlay: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        justifyContent: "center",
        alignItems: "center",
    },
    progressModal: {
        width: width * 0.9,
        maxHeight: "80%",
        backgroundColor: "#fff",
        borderRadius: 20,
        padding: 24,
    },
    modalHeader: {
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        marginBottom: 16,
    },
    modalTitle: {
        fontSize: 24,
        fontWeight: "700",
        color: colors.textPrimary,
    },
    completedText: {
        fontSize: 15,
        color: colors.textMuted,
        marginBottom: 20,
    },
    stepsList: {
        maxHeight: 300,
    },
    progressStepItem: {
        flexDirection: "row",
        alignItems: "center",
        paddingVertical: 12,
        paddingHorizontal: 16,
        backgroundColor: "#F8F8F8",
        borderRadius: 12,
        marginBottom: 8,
    },
    progressStepCircle: {
        width: 32,
        height: 32,
        borderRadius: 16,
        backgroundColor: "#E0E0E0",
        justifyContent: "center",
        alignItems: "center",
        marginRight: 12,
    },
    progressStepCircleCompleted: {
        backgroundColor: colors.accent,
    },
    progressStepCircleActive: {
        backgroundColor: colors.accent,
        borderWidth: 3,
        borderColor: "#FFE5DC",
    },
    progressStepNumber: {
        fontSize: 14,
        fontWeight: "700",
        color: "#666",
    },
    progressStepNumberActive: {
        color: "#fff",
    },
    progressStepText: {
        flex: 1,
        fontSize: 14,
        color: colors.textMuted,
    },
    progressStepTextCompleted: {
        textDecorationLine: "line-through",
    },
    progressStepTextActive: {
        color: colors.textPrimary,
        fontWeight: "600",
    },
    resumeButton: {
        backgroundColor: colors.accent,
        paddingVertical: 16,
        borderRadius: 12,
        alignItems: "center",
        marginTop: 16,
    },
    resumeButtonText: {
        fontSize: 16,
        fontWeight: "700",
        color: "#fff",
    },
});
